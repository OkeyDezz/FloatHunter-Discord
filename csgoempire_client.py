#!/usr/bin/env python3
"""
CSGOEmpire Client - Cliente limpo e novo para CSGOEmpire.
Implementa exatamente a documenta√ß√£o oficial.
"""

import asyncio
import logging
import json
import time
from typing import Dict, Optional, Callable
import aiohttp
import socketio

logger = logging.getLogger(__name__)

class CSGOEmpireClient:
    """Cliente limpo para CSGOEmpire."""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.domain = "csgoempire.com"
        self.socket_endpoint = f"wss://trade.{self.domain}/trade"
        
        # Socket.IO client
        self.sio = None
        self.is_connected = False
        self.is_authenticated = False
        
        # User data
        self.user_data = None
        self.user_data_refreshed_at = None
        
        # Callbacks
        self.on_item_callback = None
        
        # Status
        self.running = False
        
        # Headers para API
        self.api_headers = {
            'Authorization': f'Bearer {self.api_key}',
            'User-Agent': 'CSGOEmpire Opportunity Bot'
        }
        
        logger.info("üîß CSGOEmpire Client inicializado")
    
    async def get_user_metadata(self) -> bool:
        """Obt√©m metadata do usu√°rio."""
        try:
            logger.info("üîç Obtendo metadata do usu√°rio...")
            
            # Verifica se precisa atualizar (v√°lido por 30s, atualiza a cada 15s)
            if (self.user_data_refreshed_at and 
                self.user_data_refreshed_at > time.time() - 15):
                logger.debug("‚úÖ Metadata ainda v√°lida")
                return True
            
            url = f"https://{self.domain}/api/v2/metadata/socket"
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=self.api_headers) as response:
                    if response.status == 200:
                        self.user_data = await response.json()
                        self.user_data_refreshed_at = time.time()
                        
                        user_name = self.user_data.get('user', {}).get('name', 'Unknown')
                        user_id = self.user_data.get('user', {}).get('id', 'Unknown')
                        
                        logger.info(f"‚úÖ Metadata obtida: {user_name} (ID: {user_id})")
                        logger.info(f"   - Socket Token: {'‚úÖ' if self.user_data.get('socket_token') else '‚ùå'}")
                        logger.info(f"   - Socket Signature: {'‚úÖ' if self.user_data.get('socket_signature') else '‚ùå'}")
                        
                        return True
                    else:
                        logger.error(f"‚ùå Falha ao obter metadata: {response.status}")
                        return False
                        
        except Exception as e:
            logger.error(f"‚ùå Erro ao obter metadata: {e}")
            return False
    
    def setup_socket_events(self):
        """Configura eventos do Socket.IO."""
        try:
            # Cria Socket.IO client
            self.sio = socketio.AsyncClient(
                transports=['websocket'],
                logger=False,  # Desabilita logs internos
                engineio_logger=False
            )
            
            # Evento de conex√£o
            @self.sio.event
            async def connect():
                logger.info("üîó Conectado ao WebSocket CSGOEmpire")
                self.is_connected = True
                
                # Aguarda um pouco antes de identificar
                await asyncio.sleep(1)
                
                # Emite identifica√ß√£o
                if self.user_data:
                    await self.emit_identify()
                else:
                    logger.error("‚ùå Dados do usu√°rio n√£o dispon√≠veis")
            
            # Evento de desconex√£o
            @self.sio.event
            async def disconnect():
                logger.warning("üîå Desconectado do WebSocket CSGOEmpire")
                self.is_connected = False
                self.is_authenticated = False
            
            # Evento de erro de conex√£o
            @self.sio.event
            async def connect_error(data):
                logger.error(f"‚ùå Erro de conex√£o: {data}")
                self.is_connected = False
            
            # Evento INIT (autentica√ß√£o)
            @self.sio.event
            async def init(data):
                try:
                    logger.info(f"üöÄ Evento INIT recebido")
                    
                    if data and data.get('authenticated'):
                        self.is_authenticated = True
                        user_name = data.get('name', 'Unknown')
                        logger.info(f"‚úÖ Autenticado como: {user_name}")
                        
                        # Emite filtros para receber eventos
                        await self.emit_filters()
                        
                    else:
                        logger.info("üîÑ N√£o autenticado - emitindo identifica√ß√£o...")
                        await self.emit_identify()
                        
                except Exception as e:
                    logger.error(f"‚ùå Erro no evento INIT: {e}")
            
            # Evento TIMESYNC
            @self.sio.event
            async def timesync(data):
                logger.debug(f"‚è∞ Timesync: {data}")
            
            # Evento NEW_ITEM
            @self.sio.event
            async def new_item(data):
                try:
                    item_count = len(data) if isinstance(data, list) else 1
                    logger.info(f"üÜï NOVO ITEM: {item_count} item(s)")
                    
                    if self.on_item_callback:
                        if isinstance(data, list):
                            for item in data:
                                await self.on_item_callback(item, "new_item")
                        else:
                            await self.on_item_callback(data, "new_item")
                            
                except Exception as e:
                    logger.error(f"‚ùå Erro no evento new_item: {e}")
            
            # Evento UPDATED_ITEM
            @self.sio.event
            async def updated_item(data):
                try:
                    item_count = len(data) if isinstance(data, list) else 1
                    logger.info(f"üîÑ ITEM ATUALIZADO: {item_count} item(s)")
                    
                    if self.on_item_callback:
                        if isinstance(data, list):
                            for item in data:
                                await self.on_item_callback(item, "updated_item")
                        else:
                            await self.on_item_callback(data, "updated_item")
                            
                except Exception as e:
                    logger.error(f"‚ùå Erro no evento updated_item: {e}")
            
            # Evento DELETED_ITEM
            @self.sio.event
            async def deleted_item(data):
                try:
                    item_count = len(data) if isinstance(data, list) else 1
                    logger.info(f"üóëÔ∏è ITEM DELETADO: {item_count} item(s)")
                    
                except Exception as e:
                    logger.error(f"‚ùå Erro no evento deleted_item: {e}")
            
            # Evento AUCTION_UPDATE
            @self.sio.event
            async def auction_update(data):
                try:
                    item_count = len(data) if isinstance(data, list) else 1
                    logger.info(f"üè∑Ô∏è LEIL√ÉO ATUALIZADO: {item_count} item(s)")
                    
                except Exception as e:
                    logger.error(f"‚ùå Erro no evento auction_update: {e}")
            
            # Evento TRADE_STATUS
            @self.sio.event
            async def trade_status(data):
                try:
                    trade_type = data.get('type', 'unknown')
                    logger.info(f"üì¶ TRADE STATUS: {trade_type}")
                    
                except Exception as e:
                    logger.error(f"‚ùå Erro no evento trade_status: {e}")
            
            # Evento DEPOSIT_FAILED
            @self.sio.event
            async def deposit_failed(data):
                try:
                    logger.warning(f"‚ùå DEP√ìSITO FALHOU: {data}")
                    
                except Exception as e:
                    logger.error(f"‚ùå Erro no evento deposit_failed: {e}")
            
            logger.info("‚úÖ Eventos do Socket.IO configurados")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao configurar eventos: {e}")
            return False
    
    async def emit_identify(self):
        """Emite evento de identifica√ß√£o."""
        try:
            if not self.user_data:
                logger.error("‚ùå Dados do usu√°rio n√£o dispon√≠veis")
                return
            
            identify_data = {
                "uid": self.user_data['user']['id'],
                "model": self.user_data['user'],
                "authorizationToken": self.user_data['socket_token'],
                "signature": self.user_data['socket_signature'],
                "uuid": f"bot-{int(time.time())}"
            }
            
            logger.info(f"üÜî Emitindo identifica√ß√£o para UID: {identify_data['uid']}")
            await self.sio.emit('identify', identify_data)
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao emitir identifica√ß√£o: {e}")
    
    async def emit_filters(self):
        """Emite filtros para receber eventos."""
        try:
            filters = {
                "price_max": 9999999  # Filtro padr√£o da documenta√ß√£o
            }
            
            logger.info("üîç Emitindo filtros para receber eventos")
            await self.sio.emit('filters', filters)
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao emitir filtros: {e}")
    
    async def connect(self) -> bool:
        """Conecta ao WebSocket do CSGOEmpire."""
        try:
            logger.info("üîó Conectando ao WebSocket CSGOEmpire...")
            
            # Obt√©m metadata do usu√°rio
            if not await self.get_user_metadata():
                logger.error("‚ùå Falha ao obter metadata")
                return False
            
            # Configura eventos do Socket.IO
            if not self.setup_socket_events():
                logger.error("‚ùå Falha ao configurar eventos")
                return False
            
            # Par√¢metros de conex√£o
            query_params = {
                'uid': self.user_data['user']['id'],
                'token': self.user_data['socket_token']
            }
            
            # Headers extras
            extra_headers = {
                'User-agent': f"{self.user_data['user']['id']} API Bot"
            }
            
            logger.info(f"üîó Conectando a: {self.socket_endpoint}")
            logger.info(f"   - UID: {query_params['uid']}")
            logger.info(f"   - Token: {query_params['token'][:10]}...")
            
            # Conecta
            await self.sio.connect(
                self.socket_endpoint,
                query=query_params,
                headers=extra_headers,
                wait_timeout=30
            )
            
            logger.info("‚úÖ Conectado ao WebSocket CSGOEmpire")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Falha ao conectar: {e}")
            return False
    
    async def disconnect(self):
        """Desconecta do WebSocket."""
        try:
            if self.sio and self.is_connected:
                await self.sio.disconnect()
                logger.info("‚úÖ Desconectado do WebSocket CSGOEmpire")
            
            self.is_connected = False
            self.is_authenticated = False
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao desconectar: {e}")
    
    async def start(self, on_item_callback: Optional[Callable] = None):
        """Inicia o cliente."""
        try:
            logger.info("üöÄ Iniciando CSGOEmpire Client...")
            
            # Define callback
            if on_item_callback:
                self.on_item_callback = on_item_callback
                logger.info("‚úÖ Callback de item configurado")
            
            # Conecta
            if not await self.connect():
                logger.error("‚ùå Falha ao conectar")
                return False
            
            self.running = True
            logger.info("‚úÖ CSGOEmpire Client iniciado com sucesso")
            
            # Loop principal
            while self.running:
                try:
                    await asyncio.sleep(30)
                    
                    # Log de status
                    if self.is_connected and self.is_authenticated:
                        logger.info("üíì WebSocket ativo - monitorando itens...")
                    elif self.is_connected:
                        logger.warning("‚ö†Ô∏è Conectado mas n√£o autenticado...")
                    else:
                        logger.error("‚ùå WebSocket desconectado")
                        break
                        
                except Exception as e:
                    logger.error(f"‚ùå Erro no loop principal: {e}")
                    break
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao iniciar cliente: {e}")
            return False
    
    async def stop(self):
        """Para o cliente."""
        try:
            logger.info("üõë Parando CSGOEmpire Client...")
            
            self.running = False
            
            # Desconecta
            await self.disconnect()
            
            logger.info("‚úÖ CSGOEmpire Client parado")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao parar cliente: {e}")
    
    def get_status(self) -> Dict:
        """Retorna status do cliente."""
        return {
            'running': self.running,
            'connected': self.is_connected,
            'authenticated': self.is_authenticated,
            'user_data': bool(self.user_data)
        }
